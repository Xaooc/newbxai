# 01. Архитектура агента

## Общий поток
1. Оркестратор принимает сообщение пользователя и текущий `agent_state`.
2. Формируется системный промпт на основе:
   * конституции (правила поведения),
   * описания разрешённых методов и режимов безопасности,
   * текущего состояния `agent_state`,
   * последнего сообщения пользователя.
3. Сообщение передаётся в GPT-5 Thinking, модель возвращает текст с блоками `THOUGHT:`, `ACTION:`, `ASSISTANT:`.
4. Оркестратор логирует возвращённые блоки и анализирует ACTION.
5. Для каждого шага ACTION проверяется соответствие режиму безопасности и необходимость подтверждения от пользователя.
6. Если шаг требует подтверждения, он заносится в очередь ожидания и фиксируется в `agent_state.confirmations` со статусом `requested`.
7. Если шаг разрешён и подтверждён (`confirmed: true` либо ранее одобренный запрос), оркестратор вызывает `CALL_BITRIX` по порядку.
8. Для шагов с явным отклонением (`confirmation_decision: "deny"`) оркестратор отмечает запрос как `denied`, удаляет его из плана и уведомляет пользователя.
9. Результаты вызовов передаются в модуль состояния, который обновляет `agent_state`.
10. Обновлённое состояние сохраняется и передаётся пользователю вместе с текстом из блока ASSISTANT.

## Модуль GPT-клиента
* Реализован в `src/orchestrator/model_client.py`.
* Использует HTTP API OpenAI (или совместимый) и модель по умолчанию `gpt-5-thinking`. Ключ берётся из `OPENAI_API_KEY`, базовый URL может переопределяться через `OPENAI_API_BASE`.
* Формирует сообщения в формате Chat Completions: системный промпт с правилами, сообщение с сериализованным `agent_state` и пользовательский запрос.
* Следит за соблюдением формата ответа: при нарушении возвращает исключение `ModelClientError`, оркестратор фиксирует проблему и отправляет пользователю сообщение о деградации.
* При отсутствии API-ключа или сетевой ошибке также поднимает `ModelClientError`.

## Исполнение ACTION
* ACTION представлен как массив шагов вида `{ "method": "crm.deal.add", "params": {...}, "comment": "Создаём сделку" }`.
* Для каждого шага вызывается `call_bitrix(method, params)` либо выбирается альтернативный HTTP-метод, если модель указала `http_method`.
* Перед исполнением шаг проверяется на принадлежность к списку допустимых методов режима и на наличие критичных изменений (`OPPORTUNITY`, `ASSIGNED_BY_ID`, дедлайны и т.п.).
* Если требуется подтверждение, шаг фиксируется в `agent_state.confirmations` и не исполняется, пока модель явно не укажет `confirmed: true` или пока статус не будет переведён в `approved` вручную.
* Для отклонения шагов модель возвращает структуру с `confirmation_decision: "deny"`; оркестратор помечает запрос и очищает его из очереди, не вызывая Bitrix.
* После успешного вызова `_update_state_from_action` синхронизирует `agent_state.objects`. Для чтения (`crm.deal.get`, `crm.contact.get`) сохраняются актуальные идентификаторы сделки, контакта и компании и связи между ними из ответа Bitrix.
* Ошибки фиксируются, попадают в лог и отражаются в ответе пользователю.
* В режиме shadow ACTION не исполняется, но план сохраняется в лог и в поле `next_planned_actions` состояния.

## Интеграция с Bitrix24
* Все вызовы выполняются через единый вебхук `https://portal.magnitmedia.ru/rest/132/1s0mz4mw8d42bfvk/`.
* URL вебхука хранится в конфигурации клиента Bitrix и может быть переопределён переменной окружения `BITRIX_WEBHOOK_URL`.
* Оркестратор передает модели логические имена методов и параметры, не раскрывая сам URL.

## Логирование
* Для каждой итерации сохраняются: вход пользователя, блоки ответа модели, список фактических запросов к Bitrix, ответы Bitrix, обновлённый `agent_state`.
* Логи хранятся в ротационных файлах или в БД; MVP будет использовать файловый лог JSON-lines.

## Режим деградации модели
* Если GPT-клиент недоступен или нарушен формат ответа, оркестратор возвращает предсказуемый ответ-заглушку без ACTION.
* Заглушка чётко сообщает пользователю о временной недоступности автоматических действий и рекомендует повторить запрос после устранения проблемы.

## Точки расширения
* Поддержка разных каналов связи (CLI, HTTP, Telegram) добавляется через адаптеры, которые вызывают оркестратор.
* Для нескольких сессий пользователей `agent_state` хранится отдельно по идентификатору сессии.
