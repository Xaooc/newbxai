# 01. Архитектура агента

## Общий поток
1. Telegram-адаптер получает апдейт и извлекает текст сообщения вместе с идентификатором пользователя.
2. Оркестратор принимает текст, идентификатор сессии (совпадает с Telegram `user_id`) и текущий `agent_state`. Для каждого `user_id` выделяется отдельная блокировка, чтобы последовательные запросы одного сотрудника обрабатывались строго по очереди, при этом разные пользователи выполняются параллельно.
3. Формируется системный промпт на основе:
   * конституции (правила поведения),
   * описания разрешённых методов и режимов безопасности,
   * текущего состояния `agent_state`,
   * последнего сообщения пользователя.
4. Перед обращением к модели выполняется self-check: если в состоянии отсутствуют ключевые данные (нет активной цели, не задан текущий объект, есть зависшие подтверждения), формируется список предупреждений, который позже попадёт в ответ пользователю.
5. Сообщение передаётся в ChatGPT (имя модели задаётся переменной `OPENAI_MODEL`, по умолчанию `gpt-4.1`), которая возвращает текст с блоками `THOUGHT:`, `ACTION:`, `ASSISTANT:`.
6. Оркестратор логирует возвращённые блоки и анализирует ACTION.
7. Для каждого шага ACTION проверяется соответствие режиму безопасности и необходимость подтверждения от пользователя.
8. После проверки режима выполняется валидация обязательных параметров: оркестратор использует справочник методов, чтобы убедиться в наличии требуемых полей (`fields.TITLE` для `crm.deal.add`, `taskId` для `tasks.task.update`, `fields.ENTITY_ID/ENTITY_TYPE/COMMENT` для `crm.timeline.comment.add` и т.д.).
9. Если шаг требует подтверждения, он заносится в очередь ожидания и фиксируется в `agent_state.confirmations` со статусом `requested`.
10. При успешной валидации и наличии подтверждения (`confirmed: true` либо ранее одобренный запрос) оркестратор определяет HTTP-метод вызова: для чтения (например, `crm.deal.list`, `crm.status.list`, `tasks.task.list`, `sonet.group.get`) по умолчанию используется `GET`, для создания/обновления — `POST`, если модель не указала иное.
11. Для шагов с явным отклонением (`confirmation_decision: "deny"`) оркестратор отмечает запрос как `denied`, удаляет его из плана и уведомляет пользователя.
12. Результаты вызовов передаются в модуль состояния, который обновляет `agent_state`.
13. Обновлённое состояние сохраняется. Оркестратор формирует дружелюбное резюме выполненных действий и передаёт итоговый текст в Telegram-бот для отправки пользователю. Если часть запроса уже была решена ранее или self-check выявил пробелы, оркестратор дополняет ответ пояснением, что данные взяты из сохранённого контекста или какие сведения требуется уточнить.

## Модуль GPT-клиента
* Реализован в `src/orchestrator/model_client.py`.
* Использует HTTP API OpenAI (или совместимый) и модель, указанную в `OPENAI_MODEL` (если переменная не задана, применяется `gpt-4.1`). Ключ берётся из `OPENAI_API_KEY`, базовый URL может переопределяться через `OPENAI_API_BASE`.
* Формирует сообщения в формате Chat Completions: системный промпт с правилами, краткое текстовое резюме `agent_state`, затем сериализованный JSON состояния и пользовательский запрос.
* За резюме отвечает модуль `context_builder`, который выделяет активные цели, ожидающие подтверждения шаги, последние выполненные действия и известные идентификаторы. Это помогает модели действовать на основе контекста без повторных вопросов.
* Следит за соблюдением формата ответа: при нарушении возвращает исключение `ModelClientError`, оркестратор фиксирует проблему и отправляет пользователю сообщение о деградации.
* При отсутствии API-ключа или сетевой ошибке также поднимает `ModelClientError`.

## Исполнение ACTION
* ACTION представлен как массив шагов вида `{ "method": "crm.deal.add", "params": {...}, "comment": "Создаём сделку" }`.
* Перед вызовом Bitrix оркестратор проверяет наличие обязательных параметров согласно описанию в `/spec/02_bitrix_methods.md`. При отсутствии данных шаг не исполняется, в ответ пользователю добавляется предупреждение.
* Для каждого шага вызывается `call_bitrix(method, params)`; HTTP-метод определяется из шага `http_method` либо по умолчанию из справочника методов (GET для чтения списков, POST для изменений).
* Шаг с методом `batch` предварительно разбирается: оркестратор извлекает из `params.cmd` список команд, проверяет, что каждая команда ссылается только на разрешённые методы текущего режима, и формирует агрегированный отчёт. Некорректный пакет блокируется.
* Перед исполнением шаг проверяется на принадлежность к списку допустимых методов режима и на наличие критичных изменений (`OPPORTUNITY`, `ASSIGNED_BY_ID`, дедлайны и т.п.). Для `batch` эта проверка выполняется для каждого подзапроса; если хотя бы один требует подтверждения, весь пакет помечается как требующий подтверждения. Если информация для принятия решения уже есть в состоянии, модель должна использовать её, а не переспрашивать пользователя.
* Если требуется подтверждение, шаг фиксируется в `agent_state.confirmations` и не исполняется, пока модель явно не укажет `confirmed: true` или пока статус не будет переведён в `approved` вручную.
* Для отклонения шагов модель возвращает структуру с `confirmation_decision: "deny"`; оркестратор помечает запрос и очищает его из очереди, не вызывая Bitrix.
* После успешного вызова `_update_state_from_action` синхронизирует `agent_state.objects`. Для чтения (`crm.deal.get`, `crm.contact.get`, `crm.deal.list`, `crm.deal.category.list`, `crm.deal.category.stage.list`, `crm.status.list`, `sonet.group.get`, `sonet.group.user.get`) сохраняются актуальные идентификаторы и/или количество найденных элементов из ответа Bitrix.
* Ошибки фиксируются, попадают в лог и отражаются в ответе пользователю.
* В случае `event.bind` и `event.unbind` оркестратор всегда требует подтверждения, поскольку они меняют конфигурацию портала.
* В режиме shadow ACTION не исполняется, но план сохраняется в лог и в поле `next_planned_actions` состояния.

## Интеграция с Bitrix24
* Все вызовы выполняются через единый вебхук `https://portal.magnitmedia.ru/rest/132/1s0mz4mw8d42bfvk/`.
* URL вебхука хранится в конфигурации клиента Bitrix и может быть переопределён переменной окружения `BITRIX_WEBHOOK_URL`.
* Оркестратор передает модели логические имена методов и параметры, не раскрывая сам URL.
* Справочник методов (см. `/spec/02_bitrix_methods.md`) описывает обязательные поля, рекомендуемый HTTP-метод (GET или POST), ограничения на размер выборки и рискованные изменения. Оркестратор использует эту информацию для автоматического выбора HTTP-метода и валидации параметров.
* Системный промпт перечисляет разрешённые методы: `user.current`, `user.get`, `crm.contact.list`, `crm.contact.get`, `crm.company.list`, `crm.company.get`, `crm.deal.list`, `crm.deal.get`, `crm.deal.add`, `crm.deal.update`, `crm.deal.category.list`, `crm.deal.category.stage.list`, `crm.status.list`, `crm.activity.list`, `crm.activity.add`, `crm.timeline.comment.add`, `tasks.task.add`, `tasks.task.update`, `tasks.task.list`, `task.commentitem.add`, `task.checklistitem.add`, `sonet.group.get`, `sonet.group.user.get`, `batch`, `event.bind`, `event.get`, `event.unbind`. В конце промпта закреплено требование отвечать простым языком без ссылок на внутренние идентификаторы.

## Логирование
* Для каждой итерации сохраняются: вход пользователя, блоки ответа модели, список фактических запросов к Bitrix, ответы Bitrix, обновлённый `agent_state`.
* MVP ведёт per-user JSONL-логи в каталоге `data/logs`. Каждая запись дописывается атомарно под блокировкой, чтобы исключить гонки при нескольких запросах одного пользователя.
* Пакет логирования расположен в `src/app_logging`, чтобы избежать конфликта с стандартным модулем Python `logging`; оркестратор и тесты импортируют его через `from src.app_logging...`.
* Перед записью проверяется размер текущего файла. При превышении 5 МБ файл архивируется в `*.jsonl.<UTC timestamp>.gz`, после чего начинается новый основной файл.
* После создания архива `InteractionLogger` передаёт файл во внешний загрузчик, если он настроен. Штатный загрузчик использует S3-совместимое хранилище и конфигурируется переменными `LOG_ARCHIVE_S3_BUCKET`, `LOG_ARCHIVE_S3_PREFIX`, `LOG_ARCHIVE_S3_REGION`, `LOG_ARCHIVE_S3_DELETE_LOCAL` (значение `true` удаляет локальный архив после успешной отправки).
* Если загрузчик возвращает ошибку, логгер выполняет до трёх попыток с экспоненциальной задержкой (0,5 / 1 / 2 секунды). После окончательного отказа событие фиксируется как критическое, метрика `archive_upload_failures` увеличивается, а архив остаётся локально для повторной отправки.
* Фабрика `build_interaction_logger` автоматически создаёт загрузчик из окружения и при инициализации вызывает `sync_pending_archives`, чтобы выгрузить накопленные архивы. Процесс синхронизации также использует ретраи и обновляет счётчики успешных и неудачных выгрузок через `ArchiveUploadMonitor`.
* Метрики `ArchiveUploadMonitor` доступны через метод `snapshot()` и логируются по уровню INFO, что позволяет интегрировать их с внешними системами мониторинга или алертинга.
* Хранится не более 10 архивов на пользователя; более старые архивы удаляются при записи новой записи.
* Ошибки записи в лог не должны прерывать работу оркестратора: они фиксируются в стандартном логе Python и игнорируются для пользователя.
* Все временные метки формируются на основе timezone-aware времени UTC и сериализуются в ISO 8601 с суффиксом `Z`, чтобы исключить неоднозначность при анализе логов и подтверждений.

## Режим деградации модели
* Если GPT-клиент недоступен или нарушен формат ответа, оркестратор возвращает предсказуемый ответ-заглушку без ACTION.
* Заглушка чётко сообщает пользователю о временной недоступности автоматических действий и рекомендует повторить запрос после устранения проблемы.

## Точки расширения
* Поддержка дополнительных каналов связи (например, веб-интерфейса) добавляется через адаптеры, которые повторно используют оркестратор и общую загрузку конфигурации.
* Для нескольких сессий пользователей `agent_state` хранится отдельно по идентификатору сессии.

## HTTP API-адаптер
* Реализован в модуле `src/adapters/http_api.py`.
* Поднимает HTTP-сервер на базе стандартного `http.server` и обрабатывает POST-запросы на эндпоинт `/chat`.
* Тело запроса — JSON с полями `user_id` (строка) и `message` (строка). Дополнительно допускаются `mode`, `state_dir`, `log_dir`, которые переопределяют настройки оркестратора.
* Каждый запрос обязан содержать заголовок аутентификации `X-API-Key`. Значение сверяется со списком разрешённых токенов, который задаётся конфигурацией адаптера или переменной окружения `HTTP_API_TOKENS` (через запятую). При отсутствии или несоответствии токена сервер отвечает `401` с кодом `unauthorized`.
* Ведётся аудит неудачных попыток аутентификации: для каждого IP-адреса считается количество ошибок за последние `audit_window_seconds` (по умолчанию 15 минут). После `max_failed_attempts` (по умолчанию 5) адрес блокируется на `block_duration_seconds` (15 минут), клиент получает `429` с заголовком `Retry-After`, а событие записывается в лог.
* При успешной обработке сервер возвращает JSON `{ "assistant": <ответ ассистента> }` со статусом `200`.
* Валидация: если не переданы обязательные поля или JSON некорректный, сервер отвечает `400` с сообщением об ошибке.
* Необработанные исключения конвертируются в ответ `500`; сообщение ошибки логируется и не раскрывает внутренние детали клиенту.
* Экземпляр оркестратора создаётся при старте сервера через функцию `build_orchestrator` и переиспользуется между запросами.

## Конфигурация через `.env`
* При запуске приложения выполняется загрузка файла окружения (по умолчанию `.env` в корне проекта). Допускается передать альтернативный путь через аргумент командной строки `--env`.
* Файл поддерживает строки вида `КЛЮЧ=значение`, комментарии начинаются с `#`. Значения неэкранированные; пробелы по краям обрезаются.
* Переменные, уже присутствующие в окружении, не переопределяются значениями из файла.
* Обязательные ключи: `TELEGRAM_BOT_TOKEN` (токен бота), `BITRIX_WEBHOOK_URL` (если требуется переопределить базовый URL), `OPENAI_API_KEY` (если используется внешняя модель). Необязательные ключи: `AGENT_MODE`, `STATE_DIR`, `LOG_DIR`, `TELEGRAM_ALLOWED_CHATS` (через запятую, список идентификаторов чатов), `OPENAI_API_BASE`, `OPENAI_MODEL`.

## Telegram-адаптер
* Реализован в модуле `src/adapters/telegram_bot.py` на базе библиотеки `python-telegram-bot` (polling).
* Конфигурация (`TelegramBotConfig`) включает токен, режим оркестратора, пути к каталогам состояния и логов, список разрешённых чатов, административный чат для уведомлений об ошибках (`error_chat_id`), интервал опроса `poll_interval` и размер пула потоков `worker_threads` (по умолчанию 8, можно переопределить переменной `TELEGRAM_WORKER_THREADS`).
* При получении `/start` бот отправляет краткое описание возможностей и текущего режима безопасности.
* Текстовые сообщения без команд обрабатываются асинхронно: хендлер использует выделенный `ThreadPoolExecutor`, чтобы запускать оркестратор в рабочем потоке и не блокировать event loop Telegram; размер пула настраивается через конфигурацию бота.
* Нетекстовые сообщения (документы, голосовые, фото, стикеры) обрабатываются отдельным хендлером, который поясняет, что бот принимает только текст и просит описать задачу словами.
* Ответ ассистента отправляется в тот же чат. Оркестратор передаёт уже отформатированный текст без технических терминов; ошибки перефразируются в понятные подсказки. Если self-check выявил недостающие данные, предупреждение добавляется в ответ в явном виде.
* Если настроен список `TELEGRAM_ALLOWED_CHATS`, бот игнорирует сообщения из других чатов и уведомляет о запрете доступа. Каждая попытка фиксируется в логе с уровнем WARNING.
* Глобальный обработчик ошибок сообщает об исключениях в административный чат (если указан `error_chat_id`) и логирует стек. Пользователь получает дружелюбное сообщение без технических подробностей.
* Перед отправкой текст разбивается на части не длиннее 4096 символов, чтобы избежать ошибок Telegram API. Разбиение старается сохранять границы абзацев, а при необходимости длинные строки дробятся на безопасные фрагменты.

## Параллельная обработка запросов
* Telegram-адаптер хранит очередь фоновых заданий на отдельном пуле потоков (`worker_threads`, по умолчанию 8). Каждое входящее сообщение создаёт задачу обработки, которая выполняется независимо от других, поэтому несколько пользователей могут работать одновременно.
* Оркестратор содержит таблицу блокировок по `user_id`: пока запрос пользователя обрабатывается, последующие сообщения этого же сотрудника ждут завершения текущей операции. Благодаря этому не происходит гонок при чтении и записи состояния, а разные пользователи выполняются параллельно.
* После завершения обработки поток освобождается, а Telegram-хендлер отправляет итоговый ответ и прекращает индикацию «печатает…».

## Модуль запуска Telegram-бота
* Реализован в `src/app/telegram_runner.py` и инкапсулирует всю подготовку зависимостей перед стартом polling-библиотеки.
* Функция `launch_telegram_bot(env_path: str | Path | None = ".env") -> int`:
  * по необходимости загружает переменные окружения из `.env`,
  * читает настройки (`AGENT_MODE`, `STATE_DIR`, `LOG_DIR`, `TELEGRAM_ALLOWED_CHATS`, `TELEGRAM_POLL_INTERVAL`),
  * создаёт каталоги состояния и логов,
  * инициализирует оркестратор через `build_orchestrator` и собирает `TelegramBotAdapter`.
* Если токен Telegram отсутствует, `launch_telegram_bot` записывает ошибку в лог и возвращает `1`, не запуская бота.
* Модуль предоставляет `create_telegram_adapter(env_path: str | Path | None = ".env") -> TelegramBotAdapter` для сценариев, где запуск контролируется внешним кодом (например, при интеграции в сторонний сервис или тестах).
* CLI-точка входа (`src/main_entrypoint.py`) делегирует всю работу модулю запуска: парсит аргументы, гарантирует присутствие корня проекта в `sys.path`, чтобы импорт `src.*` работал как при запуске `python -m`, так и при прямом вызове файла, и вызывает `launch_telegram_bot`.

## Анализ текущей реализации и выявленные риски
* **Контекст и самопроверка.** Сводка состояния и self-check позволяют выявлять пробелы до обращения к модели, поэтому пользователь сразу видит, каких данных не хватает.
* **Telegram-канал.** Обработка сообщений вынесена в отдельный поток, а нетекстовые апдейты получают явный ответ с инструкцией. Глобальные ошибки дублируются в административный чат и лог.
* **Мониторинг логов.** Ретраи и мониторинг выгрузок архивов сокращают риск потери данных, но требуется настроить внешнее хранилище/алерты в инфраструктуре.
* **Качество подсказок модели.** Шаблоны описаний актуализированы; дополнительный слой тестов гарантирует отсутствие технических терминов в пользовательском резюме.

## Постобработка ответа для пользователя
* После выполнения действий оркестратор собирает список успешных шагов и преобразует их в короткие описания на понятном языке.
* Для каждого разрешённого метода есть шаблон описания (например, `crm.deal.add` → «Создана новая сделка»), при отсутствии специальных данных используется нейтральное пояснение.
* Сформированное резюме добавляется к тексту модели, чтобы пользователь точно понимал, что сделано и каков результат.
* Ошибки, возникающие на этапе валидации или выполнения, переводятся в дружелюбные сообщения без ссылок на методы и поля.

## Оценка текущей реализации Telegram-канала
* Оркестратор вызывается во вспомогательном потоке, поэтому event loop остаётся отзывчивым даже при долгих операциях Bitrix24.
* Нетекстовые сообщения перехватываются и получают вежливый ответ-инструкцию, что снижает риск непонимания со стороны пользователя.
* Глобальный обработчик ошибок информирует операторов через административный чат и лог. Для дальнейшего развития можно добавить интеграцию с Sentry.

## Пакетные вызовы и подписки на события
* `batch` разрешён в режимах canary и full. Оркестратор валидирует структуру `cmd`, убеждаясь, что подзапросы используют только разрешённые методы текущего режима и не содержат неизвестных HTTP-методов.
* Ответ `batch` агрегируется в одну запись лога. Для каждого подзапроса сохраняются ключ, метод и статус (успех или ошибка). Если пакет содержит несколько успешных команд, в историю `done` добавляется сводное описание с перечислением ключей и методов.
* Методы `event.bind`, `event.get`, `event.unbind` доступны в режиме full (чтение списка — также в canary). Оркестратор синхронизирует список подписок в `agent_state.event_bindings` и требует подтверждения перед изменением (`event.bind`/`event.unbind`).

## Автоматизированные тесты
* Все автотесты размещены в каталоге `tests/` и выполняются через `pytest`.
* Для проверки логики оркестратора используются заглушки GPT (`FakeModelClient`) и патчи `call_bitrix`, позволяющие имитировать ответы Bitrix24 без сетевых вызовов.
* Тесты охватывают режим `shadow`, выполнение безопасных действий в режиме `full`, обработку подтверждений, работу пакетных вызовов `batch`, сценарии управления подписками (`event.bind`/`event.unbind`/`event.get`), а также генерацию пользовательского резюме действий без технических терминов.
* Для Telegram-адаптера проверяются хендлеры `/start`, текстовых сообщений, отказов доступа, нетекстовых вложений и обработки исключений. Модуль запуска (`telegram_runner`) покрыт тестами чтения окружения и реакции на отсутствующий токен.
* Отдельные тесты проверяют валидацию обязательных параметров методов Bitrix и self-check контекста.
* Запуск тестов обязателен перед мёрджем изменений: `pytest` должен завершаться без ошибок. Для локальной проверки доступна команда `make check-warnings`, запускающая `pytest -W error::DeprecationWarning`.
* CI-пайплайн реализован в GitHub Actions (`.github/workflows/tests.yml`): он устанавливает зависимости из `requirements-dev.txt`, запускает `ruff` (линтер), `mypy` (статический анализ) и `pytest --cov=src --cov-report=xml --cov-report=term -W error::DeprecationWarning`. Отчёт покрытия публикуется артефактом `coverage.xml`.
