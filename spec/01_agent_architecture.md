# 01. Архитектура агента

## Общий поток
1. Оркестратор принимает сообщение пользователя и текущий `agent_state`.
2. Формируется системный промпт на основе:
   * конституции (правила поведения),
   * описания разрешённых методов и режимов безопасности,
   * текущего состояния `agent_state`,
   * последнего сообщения пользователя.
3. Сообщение передаётся в GPT-5 Thinking, модель возвращает текст с блоками `THOUGHT:`, `ACTION:`, `ASSISTANT:`.
4. Оркестратор логирует возвращённые блоки и анализирует ACTION.
5. Для каждого шага ACTION проверяется соответствие режиму безопасности и необходимость подтверждения от пользователя.
6. Если шаг требует подтверждения, он заносится в очередь ожидания и фиксируется в `agent_state.confirmations` со статусом `requested`.
7. Если шаг разрешён и подтверждён (`confirmed: true` либо ранее одобренный запрос), оркестратор вызывает `CALL_BITRIX` по порядку.
8. Для шагов с явным отклонением (`confirmation_decision: "deny"`) оркестратор отмечает запрос как `denied`, удаляет его из плана и уведомляет пользователя.
9. Результаты вызовов передаются в модуль состояния, который обновляет `agent_state`.
10. Обновлённое состояние сохраняется и передаётся пользователю вместе с текстом из блока ASSISTANT.

## Модуль GPT-клиента
* Реализован в `src/orchestrator/model_client.py`.
* Использует HTTP API OpenAI (или совместимый) и модель по умолчанию `gpt-5-thinking`. Ключ берётся из `OPENAI_API_KEY`, базовый URL может переопределяться через `OPENAI_API_BASE`.
* Формирует сообщения в формате Chat Completions: системный промпт с правилами, сообщение с сериализованным `agent_state` и пользовательский запрос.
* Следит за соблюдением формата ответа: при нарушении возвращает исключение `ModelClientError`, оркестратор фиксирует проблему и отправляет пользователю сообщение о деградации.
* При отсутствии API-ключа или сетевой ошибке также поднимает `ModelClientError`.

## Исполнение ACTION
* ACTION представлен как массив шагов вида `{ "method": "crm.deal.add", "params": {...}, "comment": "Создаём сделку" }`.
* Для каждого шага вызывается `call_bitrix(method, params)` либо выбирается альтернативный HTTP-метод, если модель указала `http_method`.
* Шаг с методом `batch` предварительно разбирается: оркестратор извлекает из `params.cmd` список команд, проверяет, что каждая команда ссылается только на разрешённые методы текущего режима, и формирует агрегированный отчёт. Некорректный пакет блокируется.
* Перед исполнением шаг проверяется на принадлежность к списку допустимых методов режима и на наличие критичных изменений (`OPPORTUNITY`, `ASSIGNED_BY_ID`, дедлайны и т.п.). Для `batch` эта проверка выполняется для каждого подзапроса; если хотя бы один требует подтверждения, весь пакет помечается как требующий подтверждения.
* Если требуется подтверждение, шаг фиксируется в `agent_state.confirmations` и не исполняется, пока модель явно не укажет `confirmed: true` или пока статус не будет переведён в `approved` вручную.
* Для отклонения шагов модель возвращает структуру с `confirmation_decision: "deny"`; оркестратор помечает запрос и очищает его из очереди, не вызывая Bitrix.
* После успешного вызова `_update_state_from_action` синхронизирует `agent_state.objects`. Для чтения (`crm.deal.get`, `crm.contact.get`) сохраняются актуальные идентификаторы сделки, контакта и компании и связи между ними из ответа Bitrix.
* Ошибки фиксируются, попадают в лог и отражаются в ответе пользователю.
* В случае `event.bind` и `event.unbind` оркестратор всегда требует подтверждения, поскольку они меняют конфигурацию портала.
* В режиме shadow ACTION не исполняется, но план сохраняется в лог и в поле `next_planned_actions` состояния.

## Интеграция с Bitrix24
* Все вызовы выполняются через единый вебхук `https://portal.magnitmedia.ru/rest/132/1s0mz4mw8d42bfvk/`.
* URL вебхука хранится в конфигурации клиента Bitrix и может быть переопределён переменной окружения `BITRIX_WEBHOOK_URL`.
* Оркестратор передает модели логические имена методов и параметры, не раскрывая сам URL.

## Логирование
* Для каждой итерации сохраняются: вход пользователя, блоки ответа модели, список фактических запросов к Bitrix, ответы Bitrix, обновлённый `agent_state`.
* MVP ведёт per-user JSONL-логи в каталоге `data/logs`. Каждая запись дописывается атомарно под блокировкой, чтобы исключить гонки при нескольких запросах одного пользователя.
* Перед записью проверяется размер текущего файла. При превышении 5 МБ файл архивируется в `*.jsonl.<UTC timestamp>.gz`, после чего начинается новый основной файл.
* Хранится не более 10 архивов на пользователя; более старые архивы удаляются при записи новой записи.
* Ошибки записи в лог не должны прерывать работу оркестратора: они фиксируются в стандартном логе Python и игнорируются для пользователя.
* Все временные метки формируются на основе timezone-aware времени UTC и сериализуются в ISO 8601 с суффиксом `Z`, чтобы исключить неоднозначность при анализе логов и подтверждений.

## Режим деградации модели
* Если GPT-клиент недоступен или нарушен формат ответа, оркестратор возвращает предсказуемый ответ-заглушку без ACTION.
* Заглушка чётко сообщает пользователю о временной недоступности автоматических действий и рекомендует повторить запрос после устранения проблемы.

## Точки расширения
* Поддержка разных каналов связи (CLI, HTTP, Telegram) добавляется через адаптеры, которые вызывают оркестратор.
* Для нескольких сессий пользователей `agent_state` хранится отдельно по идентификатору сессии.

## HTTP API-адаптер
* Реализован в модуле `src/adapters/http_api.py`.
* Поднимает HTTP-сервер на базе стандартного `http.server` и обрабатывает POST-запросы на эндпоинт `/chat`.
* Тело запроса — JSON с полями `user_id` (строка) и `message` (строка). Дополнительно допускаются `mode`, `state_dir`, `log_dir`, которые переопределяют настройки оркестратора.
* Каждый запрос обязан содержать заголовок аутентификации `X-API-Key`. Значение сверяется со списком разрешённых токенов, который задаётся конфигурацией адаптера или переменной окружения `HTTP_API_TOKENS` (через запятую). При отсутствии или несоответствии токена сервер отвечает `401` с кодом `unauthorized`.
* При успешной обработке сервер возвращает JSON `{ "assistant": <ответ ассистента> }` со статусом `200`.
* Валидация: если не переданы обязательные поля или JSON некорректный, сервер отвечает `400` с сообщением об ошибке.
* Необработанные исключения конвертируются в ответ `500`; сообщение ошибки логируется и не раскрывает внутренние детали клиенту.
* Экземпляр оркестратора создаётся при старте сервера через функцию `build_orchestrator` из `src/main_entrypoint.py` и переиспользуется между запросами.

## Пакетные вызовы и подписки на события
* `batch` разрешён в режимах canary и full. Оркестратор валидирует структуру `cmd`, убеждаясь, что подзапросы используют только разрешённые методы текущего режима и не содержат неизвестных HTTP-методов.
* Ответ `batch` агрегируется в одну запись лога. Для каждого подзапроса сохраняются ключ, метод и статус (успех или ошибка). Если пакет содержит несколько успешных команд, в историю `done` добавляется сводное описание с перечислением ключей и методов.
* Методы `event.bind`, `event.get`, `event.unbind` доступны в режиме full (чтение списка — также в canary). Оркестратор синхронизирует список подписок в `agent_state.event_bindings` и требует подтверждения перед изменением (`event.bind`/`event.unbind`).

## Автоматизированные тесты
* Все автотесты размещены в каталоге `tests/` и выполняются через `pytest`.
* Для проверки логики оркестратора используются заглушки GPT (`FakeModelClient`) и патчи `call_bitrix`, позволяющие имитировать ответы Bitrix24 без сетевых вызовов.
* Тесты покрывают режим `shadow`, выполнение безопасных действий в режиме `full`, обработку запросов, требующих подтверждения, а также базовую работу `InteractionLogger` (ротация и запись JSONL).
* Запуск тестов обязателен перед мёрджем изменений: `pytest` должен завершаться без ошибок.
