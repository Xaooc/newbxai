# 01. Архитектура агента

## Общий поток
1. Оркестратор принимает сообщение пользователя и текущий `agent_state`.
2. Формируется системный промпт на основе:
   * конституции (правила поведения),
   * описания разрешённых методов и режимов безопасности,
   * текущего состояния `agent_state`,
   * последнего сообщения пользователя.
3. Сообщение передаётся в GPT-5 Thinking, модель возвращает текст с блоками `THOUGHT:`, `ACTION:`, `ASSISTANT:`.
4. Оркестратор логирует возвращённые блоки и анализирует ACTION.
5. Для каждого шага ACTION проверяется соответствие режиму безопасности и необходимость подтверждения от пользователя.
6. После проверки режима выполняется валидация обязательных параметров: оркестратор использует справочник методов, чтобы убедиться в наличии требуемых полей (`fields.TITLE` для `crm.deal.add`, `taskId` для `tasks.task.update`, `fields.ENTITY_ID/ENTITY_TYPE/COMMENT` для `crm.timeline.comment.add` и т.д.).
7. Если шаг требует подтверждения, он заносится в очередь ожидания и фиксируется в `agent_state.confirmations` со статусом `requested`.
8. При успешной валидации и наличии подтверждения (`confirmed: true` либо ранее одобренный запрос) оркестратор определяет HTTP-метод вызова: для чтения (например, `crm.deal.list`, `crm.status.list`, `tasks.task.list`, `sonet.group.get`) по умолчанию используется `GET`, для создания/обновления — `POST`, если модель не указала иное.
9. Для шагов с явным отклонением (`confirmation_decision: "deny"`) оркестратор отмечает запрос как `denied`, удаляет его из плана и уведомляет пользователя.
10. Результаты вызовов передаются в модуль состояния, который обновляет `agent_state`.
11. Обновлённое состояние сохраняется и передаётся пользователю вместе с текстом из блока ASSISTANT.

## Модуль GPT-клиента
* Реализован в `src/orchestrator/model_client.py`.
* Использует HTTP API OpenAI (или совместимый) и модель по умолчанию `gpt-5-thinking`. Ключ берётся из `OPENAI_API_KEY`, базовый URL может переопределяться через `OPENAI_API_BASE`.
* Формирует сообщения в формате Chat Completions: системный промпт с правилами, сообщение с сериализованным `agent_state` и пользовательский запрос.
* Следит за соблюдением формата ответа: при нарушении возвращает исключение `ModelClientError`, оркестратор фиксирует проблему и отправляет пользователю сообщение о деградации.
* При отсутствии API-ключа или сетевой ошибке также поднимает `ModelClientError`.

## Исполнение ACTION
* ACTION представлен как массив шагов вида `{ "method": "crm.deal.add", "params": {...}, "comment": "Создаём сделку" }`.
* Перед вызовом Bitrix оркестратор проверяет наличие обязательных параметров согласно описанию в `/spec/02_bitrix_methods.md`. При отсутствии данных шаг не исполняется, в ответ пользователю добавляется предупреждение.
* Для каждого шага вызывается `call_bitrix(method, params)`; HTTP-метод определяется из шага `http_method` либо по умолчанию из справочника методов (GET для чтения списков, POST для изменений).
* Шаг с методом `batch` предварительно разбирается: оркестратор извлекает из `params.cmd` список команд, проверяет, что каждая команда ссылается только на разрешённые методы текущего режима, и формирует агрегированный отчёт. Некорректный пакет блокируется.
* Перед исполнением шаг проверяется на принадлежность к списку допустимых методов режима и на наличие критичных изменений (`OPPORTUNITY`, `ASSIGNED_BY_ID`, дедлайны и т.п.). Для `batch` эта проверка выполняется для каждого подзапроса; если хотя бы один требует подтверждения, весь пакет помечается как требующий подтверждения.
* Если требуется подтверждение, шаг фиксируется в `agent_state.confirmations` и не исполняется, пока модель явно не укажет `confirmed: true` или пока статус не будет переведён в `approved` вручную.
* Для отклонения шагов модель возвращает структуру с `confirmation_decision: "deny"`; оркестратор помечает запрос и очищает его из очереди, не вызывая Bitrix.
* После успешного вызова `_update_state_from_action` синхронизирует `agent_state.objects`. Для чтения (`crm.deal.get`, `crm.contact.get`, `crm.deal.list`, `crm.deal.category.list`, `crm.deal.category.stage.list`, `crm.status.list`, `sonet.group.get`, `sonet.group.user.get`) сохраняются актуальные идентификаторы и/или количество найденных элементов из ответа Bitrix.
* Ошибки фиксируются, попадают в лог и отражаются в ответе пользователю.
* В случае `event.bind` и `event.unbind` оркестратор всегда требует подтверждения, поскольку они меняют конфигурацию портала.
* В режиме shadow ACTION не исполняется, но план сохраняется в лог и в поле `next_planned_actions` состояния.

## Интеграция с Bitrix24
* Все вызовы выполняются через единый вебхук `https://portal.magnitmedia.ru/rest/132/1s0mz4mw8d42bfvk/`.
* URL вебхука хранится в конфигурации клиента Bitrix и может быть переопределён переменной окружения `BITRIX_WEBHOOK_URL`.
* Оркестратор передает модели логические имена методов и параметры, не раскрывая сам URL.
* Справочник методов (см. `/spec/02_bitrix_methods.md`) описывает обязательные поля, рекомендуемый HTTP-метод (GET или POST), ограничения на размер выборки и рискованные изменения. Оркестратор использует эту информацию для автоматического выбора HTTP-метода и валидации параметров.
* Системный промпт перечисляет разрешённые методы: `user.current`, `user.get`, `crm.contact.list`, `crm.contact.get`, `crm.company.list`, `crm.company.get`, `crm.deal.list`, `crm.deal.get`, `crm.deal.add`, `crm.deal.update`, `crm.deal.category.list`, `crm.deal.category.stage.list`, `crm.status.list`, `crm.activity.list`, `crm.activity.add`, `crm.timeline.comment.add`, `tasks.task.add`, `tasks.task.update`, `tasks.task.list`, `task.commentitem.add`, `task.checklistitem.add`, `sonet.group.get`, `sonet.group.user.get`, `batch`, `event.bind`, `event.get`, `event.unbind`.

## Логирование
* Для каждой итерации сохраняются: вход пользователя, блоки ответа модели, список фактических запросов к Bitrix, ответы Bitrix, обновлённый `agent_state`.
* MVP ведёт per-user JSONL-логи в каталоге `data/logs`. Каждая запись дописывается атомарно под блокировкой, чтобы исключить гонки при нескольких запросах одного пользователя.
* Перед записью проверяется размер текущего файла. При превышении 5 МБ файл архивируется в `*.jsonl.<UTC timestamp>.gz`, после чего начинается новый основной файл.
* После создания архива `InteractionLogger` передаёт файл во внешний загрузчик, если он настроен. Штатный загрузчик использует S3-совместимое хранилище и конфигурируется переменными `LOG_ARCHIVE_S3_BUCKET`, `LOG_ARCHIVE_S3_PREFIX`, `LOG_ARCHIVE_S3_REGION`, `LOG_ARCHIVE_S3_DELETE_LOCAL` (значение `true` удаляет локальный архив после успешной отправки).
* Фабрика `build_interaction_logger` автоматически создаёт загрузчик из окружения и при инициализации вызывает `sync_pending_archives`, чтобы выгрузить накопленные архивы. Ошибки загрузки логируются и не влияют на обработку пользовательских запросов.
* Хранится не более 10 архивов на пользователя; более старые архивы удаляются при записи новой записи.
* Ошибки записи в лог не должны прерывать работу оркестратора: они фиксируются в стандартном логе Python и игнорируются для пользователя.
* Все временные метки формируются на основе timezone-aware времени UTC и сериализуются в ISO 8601 с суффиксом `Z`, чтобы исключить неоднозначность при анализе логов и подтверждений.

## Режим деградации модели
* Если GPT-клиент недоступен или нарушен формат ответа, оркестратор возвращает предсказуемый ответ-заглушку без ACTION.
* Заглушка чётко сообщает пользователю о временной недоступности автоматических действий и рекомендует повторить запрос после устранения проблемы.

## Точки расширения
* Поддержка разных каналов связи (CLI, HTTP, Telegram) добавляется через адаптеры, которые вызывают оркестратор.
* Для нескольких сессий пользователей `agent_state` хранится отдельно по идентификатору сессии.

## HTTP API-адаптер
* Реализован в модуле `src/adapters/http_api.py`.
* Поднимает HTTP-сервер на базе стандартного `http.server` и обрабатывает POST-запросы на эндпоинт `/chat`.
* Тело запроса — JSON с полями `user_id` (строка) и `message` (строка). Дополнительно допускаются `mode`, `state_dir`, `log_dir`, которые переопределяют настройки оркестратора.
* Каждый запрос обязан содержать заголовок аутентификации `X-API-Key`. Значение сверяется со списком разрешённых токенов, который задаётся конфигурацией адаптера или переменной окружения `HTTP_API_TOKENS` (через запятую). При отсутствии или несоответствии токена сервер отвечает `401` с кодом `unauthorized`.
* Ведётся аудит неудачных попыток аутентификации: для каждого IP-адреса считается количество ошибок за последние `audit_window_seconds` (по умолчанию 15 минут). После `max_failed_attempts` (по умолчанию 5) адрес блокируется на `block_duration_seconds` (15 минут), клиент получает `429` с заголовком `Retry-After`, а событие записывается в лог.
* При успешной обработке сервер возвращает JSON `{ "assistant": <ответ ассистента> }` со статусом `200`.
* Валидация: если не переданы обязательные поля или JSON некорректный, сервер отвечает `400` с сообщением об ошибке.
* Необработанные исключения конвертируются в ответ `500`; сообщение ошибки логируется и не раскрывает внутренние детали клиенту.
* Экземпляр оркестратора создаётся при старте сервера через функцию `build_orchestrator` из `src/main_entrypoint.py` и переиспользуется между запросами.

## Пакетные вызовы и подписки на события
* `batch` разрешён в режимах canary и full. Оркестратор валидирует структуру `cmd`, убеждаясь, что подзапросы используют только разрешённые методы текущего режима и не содержат неизвестных HTTP-методов.
* Ответ `batch` агрегируется в одну запись лога. Для каждого подзапроса сохраняются ключ, метод и статус (успех или ошибка). Если пакет содержит несколько успешных команд, в историю `done` добавляется сводное описание с перечислением ключей и методов.
* Методы `event.bind`, `event.get`, `event.unbind` доступны в режиме full (чтение списка — также в canary). Оркестратор синхронизирует список подписок в `agent_state.event_bindings` и требует подтверждения перед изменением (`event.bind`/`event.unbind`).

## Автоматизированные тесты
* Все автотесты размещены в каталоге `tests/` и выполняются через `pytest`.
* Для проверки логики оркестратора используются заглушки GPT (`FakeModelClient`) и патчи `call_bitrix`, позволяющие имитировать ответы Bitrix24 без сетевых вызовов.
* Тесты покрывают режим `shadow`, выполнение безопасных действий в режиме `full`, обработку запросов, требующих подтверждения, работу пакетных вызовов `batch` и сценарии управления подписками (`event.bind`/`event.unbind`/`event.get`).
* Запуск тестов обязателен перед мёрджем изменений: `pytest` должен завершаться без ошибок.
* CI-пайплайн реализован в GitHub Actions (`.github/workflows/tests.yml`): он устанавливает зависимости из `requirements-dev.txt`, запускает `pytest --cov=src --cov-report=xml --cov-report=term -W error::DeprecationWarning`, что превращает `DeprecationWarning` в ошибку, и публикует артефакт покрытия `coverage.xml`.
