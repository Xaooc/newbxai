# 04. Состояние и память агента

## Формат `agent_state`
```json
{
  "goals": ["Создать сделку", "Назначить звонок"],
  "done": [
    {
      "timestamp": "2024-05-01T10:00:00Z",
      "description": "Создана сделка",
      "object_ids": {"deal_id": 123}
    }
  ],
  "in_progress": [
    {
      "description": "Ждём сумму сделки от клиента",
      "requested_at": "2024-05-01T10:05:00Z"
    }
  ],
  "objects": {
    "current_deal_id": 123,
    "current_contact_id": 456,
    "current_company_id": null,
    "current_task_id": 789
  },
  "last_plan": {
    "timestamp": "2024-05-01T09:59:00Z",
    "summary": "1) Обновить сумму сделки до 100000 ₽",
    "actions": [
      {
        "method": "crm.deal.update",
        "params": {"id": 123, "fields": {"OPPORTUNITY": 100000}},
        "comment": "Уточняем бюджет"
      }
    ]
  },
  "metrics": {
    "missing_fields": {
      "fields.SUBJECT": 3,
      "fields.RESPONSIBLE_ID": 1
    },
    "risk_warnings": {
      "OPPORTUNITY": 2,
      "RESPONSIBLE_ID": 1
    }
  },
  "event_bindings": [
    {
      "event": "onCrmDealAdd",
      "handler": "https://example.test/hook"
    }
  ]
}
```

## Правила обновления
* `goals` — список целей, сформированных из пользовательских запросов. Новые цели добавляются в начало.
* `done` — истории завершённых действий с временными метками и ID сущностей.
* `in_progress` — текущие запросы данных или действия, ожидающие дополнительной информации от пользователя.
* `objects` — последние активные сущности для контекста. Обновляются при успешных вызовах Bitrix.
  * После `crm.deal.get` фиксируются `current_deal_id`, а также `current_contact_id` и `current_company_id`, если они присутствуют в ответе сделки.
  * После `crm.deal.list`, `crm.contact.list`, `crm.company.list`, `crm.activity.list`, `tasks.task.list`, `crm.deal.category.list`, `crm.deal.category.stage.list`, `crm.status.list`, `sonet.group.get`, `sonet.group.user.get` в историю `done` добавляется запись с количеством элементов, чтобы пользователь видел объём данных.
  * После `crm.contact.get` обновляется `current_contact_id`; при наличии `COMPANY_ID` синхронизируется `current_company_id`.
  * После `crm.company.get` поле `current_company_id` обновляется значением ID компании.
* `last_plan` — последние шаги, с которыми работал оркестратор: timestamp фиксации, краткое текстовое описание и исходный список ACTION. Используется для объяснения пользователю, что планировалось сделать, и для отладки.
* `metrics` — агрегированные счётчики:
  * `missing_fields` фиксирует, какие поля чаще всего требуются дополнительно (ключ — путь параметра из ACTION, значение — количество запросов).
  * `risk_warnings` подсчитывает поля, по которым чаще всего выдавались предупреждения о рискованных изменениях.
  Эти данные обновляются при каждой итерации и попадают в служебные логи для аналитики.
* `event_bindings` — актуальный список подписок на события Bitrix24. Обновляется после `event.get`, добавления и удаления подписок; используется, чтобы модель понимала, какие вебхуки уже настроены.
* Все поля с временными метками сериализуются в формате ISO 8601 с суффиксом `Z`, полученными из timezone-aware UTC-времени.
* Подробные сообщения об ошибках Bitrix24 не сохраняются в `agent_state`; они попадают в консольные логи и JSONL через InteractionLogger.

## Self-check перед вызовом модели
* Перед генерацией промпта оркестратор анализирует `agent_state` и формирует список предупреждений.
* Проверяются как минимум следующие случаи:
  * отсутствуют актуальные цели (`goals` пустой список);
  * `objects` не содержит ни одного ID (`current_*_id` все `null`), хотя в истории `done` присутствуют записи о создании или просмотре объектов;


  * в `in_progress` остаются шаги без описания (пустая строка или `None`).
* Self-check не блокирует исполнение, но все найденные проблемы передаются в ответ пользователю отдельным списком предупреждений.

## Хранение
* Состояние хранится в файловой системе в формате JSON (один файл на пользователя/сессию).
* Оркестратор читает состояние при старте диалога и сохраняет после каждой итерации.
* Для каждого `user_id` выделяется отдельная блокировка: параллельные запросы разных пользователей выполняются одновременно, но повторные сообщения одного пользователя последовательно используют один и тот же файл состояния без гонок.

## Передача в модель
* Перед передачей в модель формируется текстовое резюме: активные цели, краткое описание последнего плана (`last_plan.summary`), последние 3 записи `done` и известные идентификаторы из `objects`. Параллельно запускается self-check и передаёт список предупреждений в оркестратор.
* В системный промпт включается сериализованное состояние, включая `last_plan` и незакрытые запросы из `in_progress`.
* При больших объёмах состояния допускается сокращение: последние 5 записей `done`, актуальные `objects`, открытые `in_progress` и сокращённый `last_plan` (не более 5 шагов). Резюме также сокращается до заданного лимита символов, сохраняя приоритет критичных сведений.
